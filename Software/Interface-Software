import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from ttkbootstrap import Style  
import serial
import serial.tools.list_ports  
import time
from functools import partial
import struct
import threading
import math
import os
import requests
import queue


# Configure the serial port
SERIAL_PORT = 'COM6' 
BAUD_RATE = 115200    
TIMEOUT = 1  

# Servo pin mapping (index 0 to 5)
SERVO_PINS = [13, 12, 14, 27, 26, 25]
SERVO_NAMES = ["Base", "Shoulder", "Upper Arm", "Elbow", "Wrist", "Hand"]

# Initialize serial connection
ser = None
serial_connected = False
command_queue = queue.Queue()
gui_queue = queue.Queue()

def process_gui_queue():
    """Process the GUI update queue."""
    while not gui_queue.empty():
        func, args = gui_queue.get()
        func(*args)
    root.after(100, process_gui_queue)  

def initialize_serial():
    global ser, serial_connected
    try:
        ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=TIMEOUT, write_timeout=5)
        time.sleep(2)  
        print(f"Connected to {SERIAL_PORT}")
        serial_connected = True
        enable_sliders()
        threading.Thread(target=read_serial_responses, daemon=True).start()
    except serial.SerialException as e:
        print(f"Error opening serial port {SERIAL_PORT}: {e}")
        ser = None
        serial_connected = False
        disable_sliders()

def close_serial():
    global ser, serial_connected
    try:
        if ser and ser.is_open:
            ser.close()
            print("Serial port closed")
        ser = None
        serial_connected = False
    except Exception as e:
        print(f"Error closing serial: {e}")
    try:
        if root and root.winfo_exists():
            disable_sliders()
    except tk.TclError:
        print("Root window has been destroyed, can't access GUI elements.")



def display_sequences_treeview(sequences):
    # Create a new window with a Treeview
    tree_window = tk.Toplevel(root)
    tree_window.title("Sequences on ESP32")
    tree = ttk.Treeview(tree_window, columns=("Name"), show='headings')
    tree.heading("Name", text="Sequence Name")
    tree.pack(fill='both', expand=True)

    for seq in sequences:
        tree.insert('', 'end', values=(seq,))

def is_serial_connected():
    """Check if the serial connection is active and update the connection status."""
    global ser, serial_connected
    if ser is None:
        return False
    if not ser.is_open:
        ser = None
        serial_connected = False
        disable_sliders()
        return False
    return True

def ease_in_out_sine(t):
    """Ease-in-out sine function for smooth transitions."""
    return -(math.cos(math.pi * t) - 1) / 2

def send_servo_angle(servo_id, angle):
    """Send a command to move a servo to a specific angle."""
    if serial_connected and is_serial_connected():
        command = f"{servo_id}:{angle}\n"
        if not command_queue.full():
            command_queue.put(command)
        else:
            print("Command queue is full, dropping command.")

def on_slider_change(servo_id, val):
    """Callback for slider movement."""
    angle = int(float(val))
    if servo_id < len(angle_labels):
        angle_labels[servo_id].config(text=f"{angle}°")
    send_servo_angle(servo_id, angle) 

def increment_angle(servo_id):
    """Increment servo angle by 5 degrees."""
    if not serial_connected:
        messagebox.showwarning("Serial Disconnected", "Please connect via Serial to control the servos.")
        return
    try:
        buttons_plus[servo_id].config(state='disabled')
        current_val = sliders[servo_id].get()
        new_val = min(current_val + 5, 180)
        sliders[servo_id].set(new_val)
        send_servo_angle(servo_id, int(new_val))
        angle_labels[servo_id].config(text=f"{int(new_val)}°")
        root.after(100, lambda: buttons_plus[servo_id].config(state='normal')) 
    except Exception as e:
        print(f"Error incrementing angle: {e}")

def decrement_angle(servo_id):
    """Decrement servo angle by 5 degrees."""
    if not serial_connected:
        messagebox.showwarning("Serial Disconnected", "Please connect via Serial to control the servos.")
        return
    try:
        buttons_minus[servo_id].config(state='disabled')
        current_val = sliders[servo_id].get()
        new_val = max(current_val - 5, 0)
        sliders[servo_id].set(new_val)
        send_servo_angle(servo_id, int(new_val))
        angle_labels[servo_id].config(text=f"{int(new_val)}°")
        root.after(100, lambda: buttons_minus[servo_id].config(state='normal'))  
    except Exception as e:
        print(f"Error decrementing angle: {e}")

def command_sender():
    """Background thread to send commands from the queue."""
    while True:
        command = command_queue.get()
        if command is None:
            break
        if serial_connected and is_serial_connected():
            try:
                ser.write(command.encode())
            except Exception as e:
                print(f"Error sending command '{command.strip()}': {e}")
        command_queue.task_done()

def read_serial_responses():
    """Background thread to read responses from the serial port."""
    while serial_connected and is_serial_connected():
        try:
            if ser.in_waiting > 0:
                raw_data = ser.readline()
                try:
                    response = raw_data.decode('utf-8', errors='ignore').strip()
                    if "Servo" in response or "Steps" in response:
                        print(response)  # Ersetzen Sie update_debug_text_box mit print
                except UnicodeDecodeError:
                    continue
        except Exception as e:
            print(f"Error reading serial response: {e}")  # Ersetzen Sie update_debug_text_box mit print

# Start the command sender thread
threading.Thread(target=command_sender, daemon=True).start()

def save_position():
    """Save the current servo positions."""
    if is_playing:
        messagebox.showwarning("Playback in Progress", "Cannot save positions while playback is in progress.")
        return
    angles = [int(slider.get()) for slider in sliders]
    saved_positions.append(angles)
    position_str = ','.join(map(str, angles))
    listbox.insert(tk.END, position_str)

def remove_position():
    """Remove selected saved positions."""
    if is_playing:
        messagebox.showwarning("Playback in Progress", "Cannot remove positions while playback is in progress.")
        return
    selected_indices = list(listbox.curselection())
    if not selected_indices:
        messagebox.showwarning("No Selection", "Please select positions to remove.")
        return
    for index in reversed(selected_indices):
        listbox.delete(index)
        saved_positions.pop(index)

def move_up():
    """Move selected positions up."""
    selected_indices = list(listbox.curselection())
    if not selected_indices:
        messagebox.showwarning("No Selection", "Please select positions to move.")
        return
    for index in selected_indices:
        if index == 0:
            continue  
        saved_positions[index - 1], saved_positions[index] = saved_positions[index], saved_positions[index - 1]
        temp = listbox.get(index - 1)
        listbox.delete(index - 1)
        listbox.insert(index, temp)
    # Update selection
    listbox.selection_clear(0, tk.END)
    for index in [i - 1 for i in selected_indices if i > 0]:
        listbox.selection_set(index)

def move_down():
    """Move selected positions down."""
    selected_indices = list(listbox.curselection())
    if not selected_indices:
        messagebox.showwarning("No Selection", "Please select positions to move.")
        return
    max_index = listbox.size() - 1
    for index in reversed(selected_indices):
        if index == max_index:
            continue  
        saved_positions[index + 1], saved_positions[index] = saved_positions[index], saved_positions[index + 1]
        temp = listbox.get(index + 1)
        listbox.delete(index + 1)
        listbox.insert(index, temp)
    # Update selection
    listbox.selection_clear(0, tk.END)
    for index in [i + 1 for i in selected_indices if i < max_index]:
        listbox.selection_set(index)

def play_sequence():
    """Start playing the saved sequence."""
    global is_playing, playback_thread
    if is_playing:
        messagebox.showwarning("Playback in Progress", "A playback is already in progress.")
        return
    if not saved_positions:
        messagebox.showwarning("No Sequences", "No saved positions to play.")
        return
    if not serial_connected:
        messagebox.showwarning("Serial Disconnected", "Please connect via Serial to play the sequence.")
        return
    is_playing = True
    playback_thread = threading.Thread(target=playback_worker, daemon=True)
    playback_thread.start()

def get_sequence_list_serial():
    """Retrieve the list of sequences from ESP32 via Serial."""
    if not serial_connected or not is_serial_connected():
        return []
    try:
        ser.reset_input_buffer()
        ser.write("LIST_SEQUENCES\n".encode())
        sequences = []
        start_time = time.time()
        while time.time() - start_time < 5:  # 5-second timeout
            if ser.in_waiting > 0:
                line = ser.readline().decode('utf-8', errors='ignore').strip()
                if line == "END_OF_LIST":
                    break
                if line:
                    sequences.append(line)
        return sequences
    except Exception as e:
        print(f"Error retrieving sequence list over Serial: {e}")
        return []

def playback_worker():
    """Worker thread for playing back the sequence."""
    global is_playing
    try:
        speed = speed_slider.get()
        min_duration = 0.5  # seconds
        max_duration = 5.0  # seconds
        total_duration = max_duration - ((speed - 1) / 9) * (max_duration - min_duration)
        update_interval = 0.02  
        steps = int(total_duration / update_interval)
        for idx, position in enumerate(saved_positions):
            if not is_playing:
                break  
            
            def highlight_step(step):
                gui_queue.put((listbox.selection_clear, (0, tk.END)))
                gui_queue.put((listbox.selection_set, (step,)))
                gui_queue.put((listbox.activate, (step,)))
            root.after(0, partial(highlight_step, idx))

            current_angles = [int(slider.get()) for slider in sliders]
            target_angles = position
            for step_num in range(steps + 1):
                if not is_playing:
                    break
                t = step_num / steps  
                ease = ease_in_out_sine(t)
                angles_step = []
                for servo_id in range(6):
                    start = current_angles[servo_id]
                    end = target_angles[servo_id]
                    delta = end - start
                    angle = start + delta * ease
                    angle = int(angle)
                    angles_step.append(angle)
                    send_servo_angle(servo_id, angle)

                def update_gui(angles):
                    for sid, angle in enumerate(angles):
                        gui_queue.put((sliders[sid].set, (angle,)))
                        gui_queue.put((angle_labels[sid].config, ({"text": f"{angle}°"})))
                root.after(0, partial(update_gui, angles_step))
                time.sleep(update_interval)
            current_angles = target_angles.copy()
        if is_playing:
            gui_queue.put((messagebox.showinfo, ("Playback Complete", "Sequence playback has completed.")))
    except Exception as e:
        gui_queue.put((messagebox.showerror, ("Playback Error", f"An error occurred during playback: {e}")))
    finally:
        is_playing = False


def stop_playback():
    """Stop the ongoing playback."""
    global is_playing
    if is_playing:
        is_playing = False
        messagebox.showinfo("Playback Stopped", "Sequence playback has been stopped.")

def play_selected_position():
    """Play a single selected position."""
    if is_playing:
        messagebox.showwarning("Playback in Progress", "Cannot play position while playback is in progress.")
        return
    selected = listbox.curselection()
    if not selected:
        messagebox.showwarning("No Selection", "Please select a position to play.")
        return
    if not serial_connected:
        messagebox.showwarning("Serial Disconnected", "Please connect via Serial to play the position.")
        return
    position_index = selected[0]
    position = saved_positions[position_index]
    threading.Thread(target=play_position_worker, args=(position, position_index), daemon=True).start()

def play_position_worker(position, position_index):
    """Worker thread for playing a single position."""
    global is_playing
    is_playing = True
    try:
        speed = speed_slider.get()
        min_duration = 0.5  
        max_duration = 5.0  
        total_duration = max_duration - ((speed - 1) / 9) * (max_duration - min_duration)
        update_interval = 0.02  
        steps = int(total_duration / update_interval)

        # Highlight the current step
        def highlight_step(step):
            gui_queue.put((listbox.selection_clear, (0, tk.END)))
            gui_queue.put((listbox.selection_set, (step,)))
            gui_queue.put((listbox.activate, (step,)))
        root.after(0, partial(highlight_step, position_index))

        current_angles = [int(slider.get()) for slider in sliders]
        target_angles = position
        for step_num in range(steps + 1):
            if not is_playing:
                break
            t = step_num / steps  
            ease = ease_in_out_sine(t)
            angles_step = []
            for servo_id in range(6):
                start = current_angles[servo_id]
                end = target_angles[servo_id]
                delta = end - start
                angle = start + delta * ease
                angle = int(angle)
                angles_step.append(angle)
                send_servo_angle(servo_id, angle)

            def update_gui(angles):
                for sid, angle in enumerate(angles):
                    gui_queue.put((sliders[sid].set, (angle,)))
                    gui_queue.put((angle_labels[sid].config, ({"text": f"{angle}°"})))
            root.after(0, partial(update_gui, angles_step))
            time.sleep(update_interval)
    except Exception as e:
        gui_queue.put((messagebox.showerror, ("Playback Error", f"An error occurred during position playback: {e}")))
    finally:
        is_playing = False


def export_sequence():
    """Export the saved sequence to a binary file."""
    if is_playing:
        messagebox.showwarning("Playback in Progress", "Cannot save sequences while playback is in progress.")
        return
    if not saved_positions:
        messagebox.showwarning("No Sequences", "No saved positions to save.")
        return
    file_path = filedialog.asksaveasfilename(defaultextension=".bin",
                                             filetypes=[("Binary Files", "*.bin")],
                                             title="Save Sequence As")
    if not file_path:
        return 
    try:
        with open(file_path, 'wb') as f:
            f.write(struct.pack('<H', len(saved_positions)))
            for position in saved_positions:
                f.write(struct.pack('<6B', *position))
        messagebox.showinfo("Save Successful", f"Sequence saved to {file_path}")
    except Exception as e:
        messagebox.showerror("Save Failed", f"Failed to save sequence: {e}")

def execute_selected_sequence_wifi(wifi_seq_listbox):
    """Execute the selected sequence via Wi-Fi with retry logic and speed control."""
    sequence_name = wifi_seq_listbox.get(tk.ACTIVE)
    if not sequence_name:
        messagebox.showwarning("No Selection", "Please select a sequence to execute.")
        return
    playback_speed = int(wifi_speed_slider.get())  
    
    print(f"Attempting to execute sequence: {sequence_name} via Wi-Fi at speed {playback_speed}")
    
    if wifi_connected:
        for attempt in range(3):  
            try:
                url = f"http://{wifi_ip}/execute_sequence"
                response = requests.post(url, data={'sequence': sequence_name, 'speed': playback_speed}, timeout=10)
                if response.status_code == 200:
                    print(f"Sequence '{sequence_name}' execution started successfully at speed {playback_speed}.")
                    messagebox.showinfo("Execution Started", f"Sequence '{sequence_name}' is being executed at speed {playback_speed}.")
                    return
                else:
                    print(f"Attempt {attempt + 1}: Failed to execute sequence. Response: {response.text}")
            except Exception as e:
                print(f"Attempt {attempt + 1}: Error executing sequence: {e}")
        print(f"Failed to execute sequence '{sequence_name}' via Wi-Fi after 3 attempts.")
        messagebox.showerror("Execution Failed", f"Failed to execute sequence via Wi-Fi after 3 attempts.")
    else:
        print("Wi-Fi connection required to execute sequences.")
        messagebox.showerror("No Connection", "Please connect via Wi-Fi to execute sequences.")


# Function to connect/disconnect Serial in Control window
def connect_serial_control(status_label, button, serial_seq_listbox, ip_label):
    """Connect or disconnect the Serial connection and update the serial listbox."""
    if serial_connected:
        close_serial()
        status_label.config(text="Not Connected", foreground="red")
        button.config(text="Connect")
        serial_seq_listbox.delete(0, tk.END)
        ip_label.config(text="ESP32 IP: N/A")
        messagebox.showinfo("Disconnected", "Serial connection closed.")
        return

    def initialize_and_update():
        initialize_serial()
        if is_serial_connected():
            status_label.config(text="Connected", foreground="green")
            button.config(text="Disconnect")
            ser.reset_input_buffer()
            ser.write("GET_IP\n".encode())
            start_time = time.time()
            ip_received = False
            while time.time() - start_time < 5:
                if ser.in_waiting > 0:
                    raw_ip = ser.readline()
                    try:
                        esp32_ip = raw_ip.decode('utf-8', errors='ignore').strip()
                        if esp32_ip:
                            ip_label.config(text=f"ESP32 IP: {esp32_ip}")
                            ip_received = True
                            break
                    except UnicodeDecodeError:
                        continue
            if not ip_received:
                ip_label.config(text="ESP32 IP: N/A")
            sequences = get_sequence_list_serial()
            serial_seq_listbox.delete(0, tk.END)
            for seq in sequences:
                serial_seq_listbox.insert(tk.END, seq)
            messagebox.showinfo("Connected", "Serial connection established.")
            # Update storage info after connection is established
            update_storage_info()
        else:
            messagebox.showerror("Connection Error", "Failed to establish Serial connection.")

    # Start the serial connection in a new thread
    threading.Thread(target=initialize_and_update, daemon=True).start()


def open_control_window():
    """Open a new window to execute sequences over Wi-Fi or Serial."""
    global wifi_speed_slider
    global storage_info_label  
    exec_window = tk.Toplevel(root)
    exec_window.title("Control")
    exec_window.geometry("600x400") 

    # Configure grid layout for exec_window
    exec_window.columnconfigure(0, weight=1)
    exec_window.columnconfigure(1, weight=1)
    exec_window.rowconfigure(0, weight=1)

    # ------------------ Serial Connection Section ------------------
    serial_frame = ttk.LabelFrame(exec_window, text="Serial Connection")
    serial_frame.grid(row=0, column=0, padx=10, pady=10, sticky=(tk.N, tk.S, tk.E, tk.W))

    # Configure grid for serial_frame
    serial_frame.columnconfigure(0, weight=1)
    serial_frame.columnconfigure(1, weight=1)
    serial_frame.rowconfigure(2, weight=1)

    # Serial Status Label
    serial_status = ttk.Label(serial_frame, text="Not Connected", foreground="red")
    serial_status.grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)

    # Connect/Disconnect Button for Serial
    serial_button = ttk.Button(
        serial_frame,
        text="Connect",
        command=lambda: connect_serial_control(serial_status, serial_button, serial_seq_listbox, serial_ip_label)
    )
    serial_button.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)

    # ESP32 IP Address Label (non-selectable)
    serial_ip_label = ttk.Label(serial_frame, text="ESP32 IP: N/A")
    serial_ip_label.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky=tk.W)

    # Serial Sequences Listbox with Scrollbar
    serial_seq_frame = ttk.Frame(serial_frame)
    serial_seq_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky=(tk.N, tk.S, tk.E, tk.W))

    serial_seq_listbox = tk.Listbox(serial_seq_frame, height=15, width=40, selectmode=tk.SINGLE)
    serial_seq_listbox.pack(side='left', fill='both', expand=True)

    serial_scrollbar_y = ttk.Scrollbar(serial_seq_frame, orient='vertical', command=serial_seq_listbox.yview)
    serial_scrollbar_y.pack(side='right', fill='y')
    serial_seq_listbox.config(yscrollcommand=serial_scrollbar_y.set)

    # Upload and Remove Buttons for Serial
    serial_buttons_frame = ttk.Frame(serial_frame)
    serial_buttons_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky=tk.W)

    upload_serial_button = ttk.Button(
        serial_buttons_frame,
        text="Upload Sequence",
        command=lambda: upload_sequence_serial(serial_seq_listbox)
    )
    upload_serial_button.grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)

    remove_serial_button = ttk.Button(
        serial_buttons_frame,
        text="Remove Sequence",
        command=lambda: remove_sequence_serial(serial_seq_listbox)
    )
    remove_serial_button.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)

    # ------------------ Wi-Fi Connection Section ------------------
    wifi_frame = ttk.LabelFrame(exec_window, text="Wi-Fi Connection")
    wifi_frame.grid(row=0, column=1, padx=10, pady=10, sticky=(tk.N, tk.S, tk.E, tk.W))

    # Configure grid for wifi_frame
    wifi_frame.columnconfigure(0, weight=1)
    wifi_frame.columnconfigure(1, weight=1)
    wifi_frame.rowconfigure(2, weight=1)

    # Wi-Fi IP Entry
    wifi_ip_label = ttk.Label(wifi_frame, text="ESP32 IP:")
    wifi_ip_label.grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
    wifi_ip_entry = ttk.Entry(wifi_frame)
    wifi_ip_entry.insert(0, '192.168.1.21')  
    wifi_ip_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)

    # Connect Button
    wifi_button = ttk.Button(
        wifi_frame,
        text="Connect",
        command=lambda: connect_wifi_control(wifi_ip_entry.get(), wifi_seq_listbox)
    )
    wifi_button.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky=tk.W)

    # Wi-Fi Sequences Listbox with Scrollbar
    wifi_seq_frame = ttk.Frame(wifi_frame)
    wifi_seq_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky=(tk.N, tk.S, tk.E, tk.W))

    wifi_seq_listbox = tk.Listbox(wifi_seq_frame, height=15, width=40, selectmode=tk.SINGLE)
    wifi_seq_listbox.pack(side='left', fill='both', expand=True)

    wifi_scrollbar_y = ttk.Scrollbar(wifi_seq_frame, orient='vertical', command=wifi_seq_listbox.yview)
    wifi_scrollbar_y.pack(side='right', fill='y')
    wifi_seq_listbox.config(yscrollcommand=wifi_scrollbar_y.set)

    # Execute Sequence Button for Wi-Fi
    execute_wifi_button = ttk.Button(
        wifi_frame,
        text="Execute Sequence",
        command=lambda: execute_selected_sequence_wifi(wifi_seq_listbox)
    )
    execute_wifi_button.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky=tk.W)

    # Speed Label for Sequence Playback
    wifi_speed_label = ttk.Label(wifi_frame, text="Playback Speed:")
    wifi_speed_label.grid(row=4, column=0, padx=5, pady=5, sticky=tk.W)

    # Speed Slider for Wi-Fi Sequence Execution
    wifi_speed_slider = ttk.Scale(wifi_frame, from_=1, to=10, orient=tk.HORIZONTAL)
    wifi_speed_slider.set(5)  
    wifi_speed_slider.grid(row=4, column=1, padx=5, pady=5, sticky=(tk.W, tk.E))

    # Speed Slider Value Label
    wifi_speed_value_label = ttk.Label(wifi_frame, text="5")
    wifi_speed_value_label.grid(row=4, column=2, padx=5, pady=5, sticky=tk.W)

    def update_wifi_speed_label(val):
        wifi_speed_value_label.config(text=str(int(float(val))))

    wifi_speed_slider.config(command=update_wifi_speed_label)

    # ------------------ Storage Info Section ------------------
    # Storage Info Status Bar
    storage_info_label = ttk.Label(exec_window, text="Storage: N/A", anchor='w')
    storage_info_label.grid(row=4, column=0, columnspan=2, padx=10, pady=5, sticky=(tk.W, tk.E))

    # ------------------ Final Configuration ------------------
    # Configure grid weights for responsive resizing
    exec_window.rowconfigure(0, weight=1)
    exec_window.columnconfigure(0, weight=1)
    exec_window.columnconfigure(1, weight=1)

    # Upload Sequence Button
    def upload_sequence_serial(serial_seq_listbox):
        """Upload a sequence to the ESP32 via Serial."""
        if is_playing:
            print("Playback in progress. Cannot upload sequences.")
            messagebox.showwarning("Playback in Progress", "Cannot upload sequences while playback is in progress.")
            return
        if not serial_connected or not is_serial_connected():
            print("Serial connection required for uploading sequences.")
            messagebox.showerror("Serial Connection Required", "Please connect via Serial to upload sequences.")
            return

        file_path = filedialog.askopenfilename(
            defaultextension=".bin",
            filetypes=[("Binary Files", "*.bin")],
            title="Select Sequence File to Upload"
        )
        if not file_path:
            print("Upload cancelled by the user.")
            return  # User cancelled

        filename = os.path.basename(file_path)
        print(f"Attempting to upload sequence: {filename}")

        try:
            with open(file_path, 'rb') as f:
                file_data = f.read()
            file_size = len(file_data)
            ser.reset_input_buffer()
            ser.reset_output_buffer()
            start_command = f"BEGIN_UPLOAD:{filename}:{file_size}\n"
            ser.write(start_command.encode())
            print(f"Upload command sent. Filename: {filename}, Size: {file_size} bytes")

            start_time = time.time()
            ack_received = False
            while time.time() - start_time < 10:  
                if ser.in_waiting > 0:
                    ack = ser.readline()
                    try:
                        ack_str = ack.decode('utf-8', errors='ignore').strip()
                        if ack_str == "ACK":
                            ack_received = True
                            break
                        elif ack_str.startswith("ERROR") or ack_str == "STORAGE_FULL":
                            print(f"Upload failed. Error from ESP32: {ack_str}")
                            messagebox.showerror("Upload Failed", f"ESP32 responded with: {ack_str}")
                            return
                    except UnicodeDecodeError:
                        continue  

            if not ack_received:
                print("No ACK received from ESP32. Upload failed.")
                messagebox.showerror("Upload Failed", "No ACK received from ESP32.")
                return

            chunk_size = 128  # Adjust chunk size as needed
            for i in range(0, file_size, chunk_size):
                chunk = file_data[i:i+chunk_size]
                ser.write(chunk)
                ser.flush()
                time.sleep(0.1)  

            end_command = "END_UPLOAD\n"
            ser.write(end_command.encode())
            print("Upload data sent. Waiting for confirmation from ESP32...")

            start_time = time.time()
            success_received = False
            while time.time() - start_time < 15: 
                if ser.in_waiting > 0:
                    response = ser.readline()
                    try:
                        response_str = response.decode('utf-8', errors='ignore').strip()
                        if response_str == "UPLOAD_SUCCESS":
                            print(f"Sequence '{filename}' uploaded successfully.")
                            messagebox.showinfo("Upload Successful", f"Sequence '{filename}' uploaded successfully.")
                            success_received = True
                            break
                        elif response_str == "STORAGE_FULL":
                            print("ESP32 storage is full. Cannot upload the sequence.")
                            messagebox.showerror("Upload Failed", "ESP32 storage is full. Cannot upload the sequence.")
                            break
                        elif response_str.startswith("ERROR"):
                            print(f"Upload failed. Error from ESP32: {response_str}")
                            messagebox.showerror("Upload Failed", f"ESP32 responded with: {response_str}")
                            break
                    except UnicodeDecodeError:
                        continue 

            if not success_received:
                print("No confirmation received from ESP32. Upload failed.")
                messagebox.showerror("Upload Failed", "No confirmation received from ESP32.")

            ser.reset_input_buffer()
            if serial_connected:
                sequences = get_sequence_list_serial()
                serial_seq_listbox.delete(0, tk.END)
                for seq in sequences:
                    serial_seq_listbox.insert(tk.END, seq)
        except Exception as e:
            print(f"Failed to upload sequence. Error: {e}")
            messagebox.showerror("Upload Failed", f"Failed to upload sequence: {e}")


    # Remove Sequence Button
    def remove_sequence_serial(serial_seq_listbox):
        """Remove a selected sequence from the ESP32 via Serial."""
        if not serial_connected or not is_serial_connected():
            print("Serial connection required to remove sequences.")
            messagebox.showerror("Serial Connection Required", "Please connect via Serial to remove sequences.")
            return

        sequence_name = serial_seq_listbox.get(tk.ACTIVE)
        if not sequence_name:
            print("No sequence selected for removal.")
            messagebox.showwarning("No Selection", "Please select a sequence to remove.")
            return

        print(f"Attempting to remove sequence: {sequence_name}")
        confirm = messagebox.askyesno("Confirm Delete", f"Are you sure you want to delete '{sequence_name}'?")
        if not confirm:
            print("Sequence removal cancelled by the user.")
            return

        try:
            command = f"DELETE_SEQUENCE:{sequence_name}\n"
            ser.reset_input_buffer()
            ser.write(command.encode())
            start_time = time.time()
            response_received = False
            while time.time() - start_time < 10:  
                if ser.in_waiting > 0:
                    response = ser.readline()
                    try:
                        response_str = response.decode('utf-8', errors='ignore').strip()
                        if response_str == "DELETE_SUCCESS":
                            print(f"Sequence '{sequence_name}' deleted successfully.")
                            messagebox.showinfo("Sequence Deleted", f"Sequence '{sequence_name}' deleted successfully.")
                            response_received = True
                            break
                        elif response_str.startswith("ERROR"):
                            print(f"Failed to delete sequence. ESP32 responded with: {response_str}")
                            messagebox.showerror("Delete Failed", f"ESP32 responded with: {response_str}")
                            response_received = True
                            break
                    except UnicodeDecodeError:
                        continue  

            if not response_received:
                print("No response received from ESP32. Sequence removal failed.")
                messagebox.showerror("Delete Failed", "No response received from ESP32.")

            if serial_connected:
                sequences = get_sequence_list_serial()
                serial_seq_listbox.delete(0, tk.END)
                for seq in sequences:
                    serial_seq_listbox.insert(tk.END, seq)
        except Exception as e:
            print(f"Failed to delete sequence. Error: {e}")
            messagebox.showerror("Delete Failed", f"Failed to delete sequence: {e}")


    # Wi-Fi Connection Variables
    global wifi_connected, wifi_ip
    wifi_connected = False
    wifi_ip = ''

    # Function to connect to Wi-Fi
    def connect_wifi_control(ip_address, wifi_seq_listbox):
        """Connect to the ESP32 via Wi-Fi and populate the Wi-Fi listbox."""
        global wifi_connected, wifi_ip
        wifi_ip = ip_address.strip()
        if not wifi_ip:
            messagebox.showwarning("Invalid IP", "Please enter a valid IP address.")
            return
        try:
            url = f"http://{wifi_ip}/list_sequences"
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                sequences = response.json()
                wifi_seq_listbox.delete(0, tk.END)
                for seq in sequences:
                    wifi_seq_listbox.insert(tk.END, seq)
                wifi_connected = True
                messagebox.showinfo("Wi-Fi Connected", f"Connected to ESP32 at {wifi_ip}")
            else:
                messagebox.showerror("Connection Failed", f"Failed to connect to ESP32: {response.text}")
                wifi_connected = False
        except Exception as e:
            messagebox.showerror("Connection Failed", f"Failed to connect to ESP32: {e}")
            wifi_connected = False

def update_storage_info():
    """Request storage info from ESP32 and update the status bar."""
    if serial_connected and is_serial_connected():
        ser.write("GET_STORAGE_INFO\n".encode()) 
        start_time = time.time()
        while time.time() - start_time < 5:  
            if ser.in_waiting > 0:
                line = ser.readline().decode('utf-8', errors='ignore').strip()
                if line.startswith("STORAGE_INFO"):
                    try:
                        _, used_bytes, total_bytes = line.split(':')
                        used_kb = int(used_bytes) / 1024
                        total_kb = int(total_bytes) / 1024
                        storage_info_label.config(text=f"Storage: {used_kb:.2f} KB / {total_kb:.2f} KB used")
                        print(f"Storage Info - Used: {used_kb:.2f} KB / Total: {total_kb:.2f} KB")
                    except ValueError:
                        print(f"Unexpected format in storage info: {line}")
                    return
        storage_info_label.config(text="Storage: N/A")
        print("Failed to retrieve storage info.")

def home_position():
    """Move servos to default position at selected speed."""
    if not serial_connected or not is_serial_connected():
        messagebox.showwarning("Serial Disconnected", "Please connect via Serial to use the Home function.")
        return
    speed = speed_slider.get()
    try:
        # Send HOME command with speed to ESP32
        command = f"HOME:{int(speed)}\n"
        command_queue.put(command)
        
        # Update sliders and angle labels to reflect home position smoothly
        for i in range(6):
            threading.Thread(target=move_servo_smoothly, args=(i, 90), daemon=True).start()
        
        # Update GUI for all servos to show 90° as the current position
        for i in range(6):
            gui_queue.put((sliders[i].set, (90,)))
            gui_queue.put((angle_labels[i].config, ({"text": f"90°"})))
        
        messagebox.showinfo("Home Command", "Moving to home position.")
    except Exception as e:
        messagebox.showerror("Home Error", f"Failed to send Home command: {e}")


def move_servo_smoothly(servo_id, target_angle, step=5, delay=20):
    """Smoothly move a servo to the target angle."""
    try:
        current_val = sliders[servo_id].get()
        while current_val != target_angle and not is_playing:
            if current_val < target_angle:
                new_val = min(current_val + step, target_angle)
            elif current_val > target_angle:
                new_val = max(current_val - step, target_angle)
            else:
                new_val = target_angle 

            if new_val != current_val:
                # Queue the GUI updates instead of direct calls
                gui_queue.put((sliders[servo_id].set, (new_val,)))
                gui_queue.put((angle_labels[servo_id].config, ({"text": f"{int(new_val)}°"})))
                send_servo_angle(servo_id, int(new_val))
                current_val = new_val
                time.sleep(delay / 1000.0) 
    except Exception as e:
        print(f"Error during smooth servo movement: {e}")

def enable_sliders():
    """Enable sliders and buttons."""
    if not sliders:
        return
    for slider in sliders:
        slider.config(state='normal')
    for btn in buttons_plus + buttons_minus:
        btn.config(state='normal')

def disable_sliders():
    """Disable sliders and buttons."""
    if not sliders:
        return
    for slider in sliders:
        if str(slider):
            slider.config(state='disabled')
    for btn in buttons_plus + buttons_minus:
        if str(btn):
            btn.config(state='disabled')

# Create the main window with dark theme
style = Style('darkly') 
root = style.master
root.title("Robot Arm Programming Interface")

# Lists to store sliders, labels, and buttons
sliders = []
angle_labels = []
buttons_plus = []
buttons_minus = []
saved_positions = [] 

# Flag to indicate if a sequence is being played
is_playing = False
playback_thread = None

# Create a frame for sliders and buttons
frame = ttk.Frame(root, padding="10")
frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

# Create sliders, labels, and buttons for each servo
for i in range(6):
    servo_label = ttk.Label(frame, text=f"{SERVO_NAMES[i]}")
    servo_label.grid(row=i, column=0, pady=5, sticky=tk.W)
    btn_decrement = ttk.Button(frame, text='-', width=3, command=partial(decrement_angle, i))
    btn_decrement.grid(row=i, column=1, padx=5)
    buttons_minus.append(btn_decrement)
    slider = ttk.Scale(frame, from_=0, to=180, orient=tk.HORIZONTAL)
    slider.set(90)  
    slider.grid(row=i, column=2, pady=5, padx=5, sticky=(tk.W, tk.E))
    sliders.append(slider)
    btn_increment = ttk.Button(frame, text='+', width=3, command=partial(increment_angle, i))
    btn_increment.grid(row=i, column=3, padx=5)
    buttons_plus.append(btn_increment)
    angle_label = ttk.Label(frame, text="90°")
    angle_label.grid(row=i, column=4, pady=5, sticky=tk.W)
    angle_labels.append(angle_label)

# Now set the command for sliders after angle_labels is populated
for i, slider in enumerate(sliders):
    slider.config(command=partial(on_slider_change, i))

# Configure grid weights
frame.columnconfigure(2, weight=1)

# Disable sliders initially
disable_sliders()

# Create a separator
separator = ttk.Separator(root, orient='horizontal')
separator.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=10)

# Create a frame for sequence management
seq_frame = ttk.Frame(root, padding="10")
seq_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

# Grouped Buttons Frame
buttons_frame = ttk.LabelFrame(seq_frame, text="Position Management")
buttons_frame.grid(row=0, column=0, columnspan=5, pady=5, sticky=(tk.W, tk.E))

# Save Position Button
btn_save = ttk.Button(buttons_frame, text="Save Position", command=save_position)
btn_save.grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)

# Remove Position Button
btn_remove = ttk.Button(buttons_frame, text="Remove Position", command=remove_position)
btn_remove.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)

# Move Up Button
btn_move_up = ttk.Button(buttons_frame, text="Move Up", command=move_up)
btn_move_up.grid(row=0, column=2, padx=5, pady=5, sticky=tk.W)

# Move Down Button
btn_move_down = ttk.Button(buttons_frame, text="Move Down", command=move_down)
btn_move_down.grid(row=0, column=3, padx=5, pady=5, sticky=tk.W)

# Listbox to display saved positions
listbox = tk.Listbox(seq_frame, height=10, width=50, selectmode=tk.MULTIPLE)
listbox.grid(row=1, column=0, columnspan=5, pady=5, sticky=(tk.W, tk.E))

# Scrollbar for the listbox
scrollbar = ttk.Scrollbar(seq_frame, orient='vertical', command=listbox.yview)
listbox.configure(yscrollcommand=scrollbar.set)
scrollbar.grid(row=1, column=5, sticky=(tk.N, tk.S))

# Playback Buttons Frame
playback_frame = ttk.LabelFrame(seq_frame, text="Playback Controls")
playback_frame.grid(row=2, column=0, columnspan=5, pady=5, sticky=(tk.W, tk.E))

# Play Sequence Button
btn_play = ttk.Button(playback_frame, text="Play Sequence", command=play_sequence)
btn_play.grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)

# Play Position Button
btn_play_position = ttk.Button(playback_frame, text="Play Position", command=play_selected_position)
btn_play_position.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)

# Stop Playback Button
btn_stop = ttk.Button(playback_frame, text="Stop Playback", command=stop_playback)
btn_stop.grid(row=0, column=2, padx=5, pady=5, sticky=tk.W)

# Save Sequence Button
btn_export = ttk.Button(playback_frame, text="Save Sequence", command=export_sequence)
btn_export.grid(row=0, column=3, padx=5, pady=5, sticky=tk.W)

# Other Controls Frame
other_controls_frame = ttk.LabelFrame(seq_frame, text="Other Controls")
other_controls_frame.grid(row=3, column=0, columnspan=5, pady=5, sticky=(tk.W, tk.E))

# Control Button
btn_execute = ttk.Button(other_controls_frame, text="Control", command=open_control_window)
btn_execute.grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)

# Home Button
btn_home = ttk.Button(other_controls_frame, text="Home", command=home_position)
btn_home.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)

# Speed Slider Label
speed_label = ttk.Label(other_controls_frame, text="Playback Speed:")
speed_label.grid(row=0, column=2, padx=5, pady=5, sticky=tk.W)

# Speed Slider
speed_slider = ttk.Scale(other_controls_frame, from_=1, to=10, orient=tk.HORIZONTAL)
speed_slider.set(5)  
speed_slider.grid(row=0, column=3, padx=5, pady=5, sticky=(tk.W, tk.E))

# Speed Slider Value Label
speed_value_label = ttk.Label(other_controls_frame, text="5")
speed_value_label.grid(row=0, column=4, padx=5, pady=5, sticky=tk.W)

def update_speed_label(val):
    speed_value_label.config(text=str(int(float(val))))

speed_slider.config(command=update_speed_label)

# Configure grid weights for sequence frame
seq_frame.columnconfigure(0, weight=1)
seq_frame.columnconfigure(1, weight=1)
seq_frame.columnconfigure(2, weight=1)
seq_frame.columnconfigure(3, weight=1)
seq_frame.columnconfigure(4, weight=1)

# Function to gradually move servos to 90° on startup
def gradual_reset(servo_id=0, step=5):
    if servo_id >= len(sliders):
        return  
    try:
        current_val = sliders[servo_id].get()
        target_val = 90
        if current_val < target_val:
            new_val = min(current_val + step, target_val)
        elif current_val > target_val:
            new_val = max(current_val - step, target_val)
        else:
            new_val = target_val  
        if new_val != current_val:
            sliders[servo_id].set(new_val)
            send_servo_angle(servo_id, int(new_val))
            angle_labels[servo_id].config(text=f"{int(new_val)}°")
        root.after(50, partial(gradual_reset, servo_id + 1, step))
    except Exception as e:
        print(f"Error during gradual reset: {e}")

def on_closing():
    """Handle the window close event."""
    if messagebox.askokcancel("Quit", "Do you want to quit?"):
        close_serial()
        root.destroy()
root.protocol("WM_DELETE_WINDOW", on_closing)

# Start the gradual reset after the GUI has initialized
root.after(1000, gradual_reset)  # Start after 1 second
root.after(100, process_gui_queue)

# Run the GUI loop
root.mainloop()

# Close serial connection on exit
close_serial()
